# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from dji_osdk_ros/GenerateWaypointV2ActionRequest.msg. Do not edit."""
import codecs
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import dji_osdk_ros.msg

class GenerateWaypointV2ActionRequest(genpy.Message):
  _md5sum = "c4bc97054e3ed2f4b4ffe5d6f4908d17"
  _type = "dji_osdk_ros/GenerateWaypointV2ActionRequest"
  _has_header = False  # flag to mark the presence of a Header object
  _full_text = """#request
WaypointV2Action[] actions

================================================================================
MSG: dji_osdk_ros/WaypointV2Action
# This class represents an action for ``DJIWaypointV2Mission``. It
# determines how action is performed when a waypoint mission is executed.

# The action will be triggered when action associated executes.
# The parameters should be defined by ``DJIWaypointV2Action_DJIWaypointV2AssociateTriggerParam``.
uint8 DJIWaypointV2ActionTriggerTypeActionAssociated = 2

# The action will be triggered when the aircraft flies from one waypoint to the next.
# The parameters should be defined by ``DJIWaypointV2Action_DJIWaypointV2TrajectoryTriggerParam``.
uint8 DJIWaypointV2ActionTriggerTypeTrajectory = 3

# The action will be triggered when the aircraft flies between two waypoints
# The parameters should be defined by ``DJIWaypointV2Action_DJIWaypointV2IntervalTriggerParam``.
uint8 DJIWaypointV2ActionTriggerTypeInterval = 4
uint8 DJIWaypointV2ActionTriggerTypeSampleReachPoint = 5

# Unknown
uint8 DJIWaypointV2ActionTriggerTypeUnknown = 255

#contant for waypointV2ActuatorTriggerType
# The action will be executed by the camera.
# The parameters should be defined by ``DJIWaypointV2Action_DJIWaypointV2CameraActuatorParam``.
uint8 DJIWaypointV2ActionActuatorTypeCamera = 1

# The action will be executed by the gimbal.
# The parameters should be defined by ``DJIWaypointV2Action_DJIWaypointV2GimbalActuatorParam``.
uint8 DJIWaypointV2ActionActuatorTypeGimbal = 2

# The action will executes by control aircraft.
# The parameters should be setting by ``DJIWaypointV2Action_DJIWaypointV2CameraActuatorParam``.
uint8 DJIWaypointV2ActionActuatorTypeAircraftControl = 4

# Unknown actuator type.
uint8 DJIWaypointV2ActionActuatorTypeUnknown = 255

uint16 actionId # The ID of Action.

uint8 waypointV2ActionTriggerType
uint8 waypointV2ACtionActuatorType

# The trigger of action.You can only choose one to config
WaypointV2AssociateTrigger waypointV2AssociateTrigger
WaypointV2IntervalTrigger waypointV2IntervalTrigger
WaypointV2TrajectoryTrigger waypointV2TrajectoryTrigger
WaypointV2SampleReachPointTrigger waypointV2SampleReachPointTrigger

 # The actuator of action.You can only choose one to config
WaypointV2CameraActuator waypointV2CameraActuator
WaypointV2GimbalActuator waypointV2GimbalActuator
WaypointV2AircraftControlActuator waypointV2AircraftControlActuator
================================================================================
MSG: dji_osdk_ros/WaypointV2AssociateTrigger
#contant for actionAssociatedType
uint8 DJIWaypointV2TriggerAssociatedTimingTypeSimultaneously = 1  # The trigger starts simultaneously with the trigger that is associated.
uint8 DJIWaypointV2TriggerAssociatedTimingTypeAfterFinised = 2    # The trigger starts after the trigger associated has finished.
uint8 DJIWaypointV2TriggerAssociatedTimingTypeUnknown = 255       # Unkown timing type.

uint8 actionAssociatedType  # The type of assciate trigger.
uint8 waitingTime           # Waiting time in seconds after ActionTrigger starts.
uint16 actionIdAssociated # Associated action ID.
================================================================================
MSG: dji_osdk_ros/WaypointV2IntervalTrigger
#constant for actionIntervalType
uint8 DJIWaypointV2ActionIntervalTypeTime     = 1  # The action will be repeated after a particular period of time.
uint8 DJIWaypointV2ActionIntervalTypeDistance = 2  # The action will be repeated after a particular distance.
uint8 DJIWaypointV2ActionIntervalTypeUnknown  = 255 # Unknown action trigger type.

uint16 startIndex # It determines the index of the waypoint at which the trigger starts.
# If the  ``DJIWaypointV2Action_DJIWaypointV2IntervalTriggerParam_actionIntervalType``
# is ``DJIWaypointV2MissionV2_DJIWaypointV2TriggerAssociatedTimingType_Time``
# The time interval in seconds when two action are executed as the aircraft moves
# from the current waypoint to the next waypoint.
# If the ``DJIWaypointV2Action_DJIWaypointV2IntervalTriggerParam_actionIntervalType`` is
# ``DJIWaypointV2MissionV2_DJIWaypointV2TriggerAssociatedTimingType_Distance``
# The distance interval in meters when two action are executed as the aircraft moves
# from the current waypoint to the next waypoint.
uint16 interval
uint8 actionIntervalType # The type of interval trigger.
                         # See ``DJIWaypointV2MissionV2_DJIWaypointV2ActionIntervalType``.
================================================================================
MSG: dji_osdk_ros/WaypointV2TrajectoryTrigger
# This class represents a trajectory trigger action when should be trigger.

uint16 startIndex # It determines the index of the waypoint at which the trigger starts.
uint16 endIndex   # It determines the waypoint when the trigger stops.


================================================================================
MSG: dji_osdk_ros/WaypointV2SampleReachPointTrigger
uint16 waypointIndex # It determines the index of the waypoint at which the action will be triggered.
uint16 terminateNum

================================================================================
MSG: dji_osdk_ros/WaypointV2CameraActuator
# This determines how the camera will be performed when a waypoint mission is executing.
#constant for DJIWaypointV2ActionActuatorCameraOperationType
# Starts to shoot a photo.
uint16 DJIWaypointV2ActionActuatorCameraOperationTypeTakePhoto = 1
# Starts to record a video.
uint16 DJIWaypointV2ActionActuatorCameraOperationTypeStartRecordVideo = 2
# Stops to record a video.
uint16 DJIWaypointV2ActionActuatorCameraOperationTypeStopRecordVideo = 3
# Starts focus.
uint16 DJIWaypointV2ActionActuatorCameraOperationTypeFocus = 4
# Starts focal lenth. Only support those support flocal lenth cameras.
uint16 DJIWaypointV2ActionActuatorCameraOperationTypeFocalLength = 5

uint16 actuatorIndex   # The index of actuator. It is valid when the diagnostics is related
                      # to camera or gimbal and the connected product has multiple gimbals and cameras.

uint16 DJIWaypointV2ActionActuatorCameraOperationType
# you can only choose one to config.
WaypointV2CameraActuatorFocusParam focusParam  # The parameters for camera focus operation. It is valid only when
                                       # ``DJIWaypointV2Action_DJIWaypointV2CameraActuatorParam_operationType`` is
                                       # ``DJIWaypointV2MissionV2_DJIWaypointV2ActionActuatorCameraOperationType_Focus``
WaypointV2CameraActuatorFocalLengthParam zoomParam # The parameters for camera focus length operation. It is valid only when
                                           # ``DJIWaypointV2Action_DJIWaypointV2CameraActuatorParam_operationType`` is
                                           # ``DJIWaypointV2MissionV2_DJIWaypointV2ActionActuatorCameraOperationType_FocalLength``
================================================================================
MSG: dji_osdk_ros/WaypointV2CameraActuatorFocusParam
# This class defines a camera focus operation for ``DJIWaypointV2Action_DJIWaypointV2CameraActuatorParam``.
# The lens focus target point. When the focus mode is auto, the target point
# is the focal point. When the focus mode is manual, the target point is the zoom
# out area if the focus assistant is enabled for the manual mode.
#  The range for x and y is from 0.0 to 1.0. The point [0.0, 0.0] represents the top-left angle of the screen.
  
  float32 x # x axis focus point value.range: [0,1]
  float32 y # y axis focus point value.range: [0,1]
  uint8 regionType #focus type:0:point focus,1:rectangle focus
  float32 width #Normalized focus area width(0,1)
  float32 height # Normalized focus area height(0,1)
  uint8 retryTimes = 1
================================================================================
MSG: dji_osdk_ros/WaypointV2CameraActuatorFocalLengthParam
# This class defines a camera focal length operation for  ``DJIWaypointV2Action_DJIWaypointV2CameraActuatorParam``.
# Focal length of zoom lens. Valid range is [``DJICamera_DJICameraOpticalZoomSpec_minFocalLength``,
# ``DJICamera_DJICameraOpticalZoomSpec_minFocalLength``] and must be a multiple of
# ``DJICamera_DJICameraOpticalZoomSpec_focalLengthStep``.
#  Only support by those camera ``DJICamera_CameraSettings_isOpticalZoomSupported`` return ``TRUE``.
  uint16 focalLength

  uint8 retryTimes = 1
================================================================================
MSG: dji_osdk_ros/WaypointV2GimbalActuator
# gimbal actuator will be performed when a waypoint mission is executed.
#constant for DJIWaypointV2ActionActuatorGimbalOperationType
# Rotates the gimbal. Only valid when the trigger type is
# ``DJIWaypointV2MissionV2_DJIWaypointV2TriggerAssociatedTimingType_ReachPoint``.
uint8 DJIWaypointV2ActionActuatorGimbalOperationTypeRotateGimbal = 1
# Unknown
uint8 DJIWaypointV2ActionActuatorGimbalOperationTypeUnknown = 255

uint8 DJIWaypointV2ActionActuatorGimbalOperationType
uint16 actuatorIndex   # The index of actuator. It is valid when the diagnostics is related
                      # to camera or gimbal and the connected product has multiple gimbals and cameras.
WaypointV2GimbalActuatorRotationParam waypointV2GimbalActuatorRotationParam # The operation type of gimbal actuator.
================================================================================
MSG: dji_osdk_ros/WaypointV2GimbalActuatorRotationParam
  int16 x             # gimbal roll angle,  unit: 0.1 deg,range:[-3600, 3600]*/
  int16 y             # gimbal pitch angle, unit: 0.1 deg,range:[-3600, 3600]*/
  int16 z             # gimbal yaw angle,   unit: 0.1 deg,range:[-3600, 3600]*/
  uint8 ctrl_mode     # 0: absolute position control, 1:relative position control*/
  uint8 rollCmdIgnore # 0: roll command normal,  1: roll command ignore*/
  uint8 pitchCmdIgnore# 0: pitch command normal,  1: pitch command ignore*/
  uint8 yawCmdIgnore  # 0: yaw command normal,  1: yaw command ignore*/
  uint8 absYawModeRef # 0: absoluate rotate yaw relative to aircraft,
                      #  1: absoluate rotate yaw relative to North*/
  uint8 duationTime    # 0: rotate time,unit:0.1s, range[1,255]*/
================================================================================
MSG: dji_osdk_ros/WaypointV2AircraftControlActuator
# Parameters for aircraft control actuator. It is valid only when the
# ``DJIWaypointV2Action_DJIWaypointV2Actuator_type`` is
# ``DJIWaypointV2MissionV2_DJIWaypointV2ActionActuatorType_AircraftControl``.
#contant for DJIWaypointV2ActionActuatorAircraftControlOperationType
# Rotates the aircraft's yaw.
uint8 DJIWaypointV2ActionActuatorAircraftControlOperationTypeRotateYaw = 1
# Keeps the aircraft stop flying or start flying.
uint8 DJIWaypointV2ActionActuatorAircraftControlOperationTypeFlyingControl = 2
# Unknown
uint8 DJIWaypointV2ActionActuatorAircraftControlOperationTypeUnknown = 255

uint8 actuatorIndex   # The index of actuator. It is valid when the diagnostics is related
                      # to camera or gimbal and the connected product has multiple gimbals and cameras.
uint16 DJIWaypointV2ActionActuatorAircraftControlOperationType 
WaypointV2AircraftControlActuatorFlying waypointV2AircraftControlActuatorFlying
WaypointV2AircraftControlActuatorRotateHeading waypointV2AircraftControlActuatorRotateHeading
================================================================================
MSG: dji_osdk_ros/WaypointV2AircraftControlActuatorFlying
# This class defines if the aircraft starts or stops the flight.s.
uint8  isStartFlying  # Determines the aircraft start flying or stop flying.
                        # ``TRUE`` for the aircraft to start flying.
================================================================================
MSG: dji_osdk_ros/WaypointV2AircraftControlActuatorRotateHeading
# This class defines how the aircraft rotates on the yaw axis.
  uint8 isRelative # Determines the aircraft rotate heading relative.
                     # if ``TRUE``, when the aircraft is rotating, relative to the current angle.
  float32 yaw # Determines the direction how aircraft changes its heading."""
  __slots__ = ['actions']
  _slot_types = ['dji_osdk_ros/WaypointV2Action[]']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       actions

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(GenerateWaypointV2ActionRequest, self).__init__(*args, **kwds)
      # message fields cannot be None, assign default values for those that are
      if self.actions is None:
        self.actions = []
    else:
      self.actions = []

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      length = len(self.actions)
      buff.write(_struct_I.pack(length))
      for val1 in self.actions:
        _x = val1
        buff.write(_get_struct_H2B().pack(_x.actionId, _x.waypointV2ActionTriggerType, _x.waypointV2ACtionActuatorType))
        _v1 = val1.waypointV2AssociateTrigger
        _x = _v1
        buff.write(_get_struct_2BH().pack(_x.actionAssociatedType, _x.waitingTime, _x.actionIdAssociated))
        _v2 = val1.waypointV2IntervalTrigger
        _x = _v2
        buff.write(_get_struct_2HB().pack(_x.startIndex, _x.interval, _x.actionIntervalType))
        _v3 = val1.waypointV2TrajectoryTrigger
        _x = _v3
        buff.write(_get_struct_2H().pack(_x.startIndex, _x.endIndex))
        _v4 = val1.waypointV2SampleReachPointTrigger
        _x = _v4
        buff.write(_get_struct_2H().pack(_x.waypointIndex, _x.terminateNum))
        _v5 = val1.waypointV2CameraActuator
        _x = _v5
        buff.write(_get_struct_2H().pack(_x.actuatorIndex, _x.DJIWaypointV2ActionActuatorCameraOperationType))
        _v6 = _v5.focusParam
        _x = _v6
        buff.write(_get_struct_2fB2f().pack(_x.x, _x.y, _x.regionType, _x.width, _x.height))
        _v7 = _v5.zoomParam
        _x = _v7.focalLength
        buff.write(_get_struct_H().pack(_x))
        _v8 = val1.waypointV2GimbalActuator
        _x = _v8
        buff.write(_get_struct_BH().pack(_x.DJIWaypointV2ActionActuatorGimbalOperationType, _x.actuatorIndex))
        _v9 = _v8.waypointV2GimbalActuatorRotationParam
        _x = _v9
        buff.write(_get_struct_3h6B().pack(_x.x, _x.y, _x.z, _x.ctrl_mode, _x.rollCmdIgnore, _x.pitchCmdIgnore, _x.yawCmdIgnore, _x.absYawModeRef, _x.duationTime))
        _v10 = val1.waypointV2AircraftControlActuator
        _x = _v10
        buff.write(_get_struct_BH().pack(_x.actuatorIndex, _x.DJIWaypointV2ActionActuatorAircraftControlOperationType))
        _v11 = _v10.waypointV2AircraftControlActuatorFlying
        _x = _v11.isStartFlying
        buff.write(_get_struct_B().pack(_x))
        _v12 = _v10.waypointV2AircraftControlActuatorRotateHeading
        _x = _v12
        buff.write(_get_struct_Bf().pack(_x.isRelative, _x.yaw))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.actions is None:
        self.actions = None
      end = 0
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.actions = []
      for i in range(0, length):
        val1 = dji_osdk_ros.msg.WaypointV2Action()
        _x = val1
        start = end
        end += 4
        (_x.actionId, _x.waypointV2ActionTriggerType, _x.waypointV2ACtionActuatorType,) = _get_struct_H2B().unpack(str[start:end])
        _v13 = val1.waypointV2AssociateTrigger
        _x = _v13
        start = end
        end += 4
        (_x.actionAssociatedType, _x.waitingTime, _x.actionIdAssociated,) = _get_struct_2BH().unpack(str[start:end])
        _v14 = val1.waypointV2IntervalTrigger
        _x = _v14
        start = end
        end += 5
        (_x.startIndex, _x.interval, _x.actionIntervalType,) = _get_struct_2HB().unpack(str[start:end])
        _v15 = val1.waypointV2TrajectoryTrigger
        _x = _v15
        start = end
        end += 4
        (_x.startIndex, _x.endIndex,) = _get_struct_2H().unpack(str[start:end])
        _v16 = val1.waypointV2SampleReachPointTrigger
        _x = _v16
        start = end
        end += 4
        (_x.waypointIndex, _x.terminateNum,) = _get_struct_2H().unpack(str[start:end])
        _v17 = val1.waypointV2CameraActuator
        _x = _v17
        start = end
        end += 4
        (_x.actuatorIndex, _x.DJIWaypointV2ActionActuatorCameraOperationType,) = _get_struct_2H().unpack(str[start:end])
        _v18 = _v17.focusParam
        _x = _v18
        start = end
        end += 17
        (_x.x, _x.y, _x.regionType, _x.width, _x.height,) = _get_struct_2fB2f().unpack(str[start:end])
        _v19 = _v17.zoomParam
        start = end
        end += 2
        (_v19.focalLength,) = _get_struct_H().unpack(str[start:end])
        _v20 = val1.waypointV2GimbalActuator
        _x = _v20
        start = end
        end += 3
        (_x.DJIWaypointV2ActionActuatorGimbalOperationType, _x.actuatorIndex,) = _get_struct_BH().unpack(str[start:end])
        _v21 = _v20.waypointV2GimbalActuatorRotationParam
        _x = _v21
        start = end
        end += 12
        (_x.x, _x.y, _x.z, _x.ctrl_mode, _x.rollCmdIgnore, _x.pitchCmdIgnore, _x.yawCmdIgnore, _x.absYawModeRef, _x.duationTime,) = _get_struct_3h6B().unpack(str[start:end])
        _v22 = val1.waypointV2AircraftControlActuator
        _x = _v22
        start = end
        end += 3
        (_x.actuatorIndex, _x.DJIWaypointV2ActionActuatorAircraftControlOperationType,) = _get_struct_BH().unpack(str[start:end])
        _v23 = _v22.waypointV2AircraftControlActuatorFlying
        start = end
        end += 1
        (_v23.isStartFlying,) = _get_struct_B().unpack(str[start:end])
        _v24 = _v22.waypointV2AircraftControlActuatorRotateHeading
        _x = _v24
        start = end
        end += 5
        (_x.isRelative, _x.yaw,) = _get_struct_Bf().unpack(str[start:end])
        self.actions.append(val1)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      length = len(self.actions)
      buff.write(_struct_I.pack(length))
      for val1 in self.actions:
        _x = val1
        buff.write(_get_struct_H2B().pack(_x.actionId, _x.waypointV2ActionTriggerType, _x.waypointV2ACtionActuatorType))
        _v25 = val1.waypointV2AssociateTrigger
        _x = _v25
        buff.write(_get_struct_2BH().pack(_x.actionAssociatedType, _x.waitingTime, _x.actionIdAssociated))
        _v26 = val1.waypointV2IntervalTrigger
        _x = _v26
        buff.write(_get_struct_2HB().pack(_x.startIndex, _x.interval, _x.actionIntervalType))
        _v27 = val1.waypointV2TrajectoryTrigger
        _x = _v27
        buff.write(_get_struct_2H().pack(_x.startIndex, _x.endIndex))
        _v28 = val1.waypointV2SampleReachPointTrigger
        _x = _v28
        buff.write(_get_struct_2H().pack(_x.waypointIndex, _x.terminateNum))
        _v29 = val1.waypointV2CameraActuator
        _x = _v29
        buff.write(_get_struct_2H().pack(_x.actuatorIndex, _x.DJIWaypointV2ActionActuatorCameraOperationType))
        _v30 = _v29.focusParam
        _x = _v30
        buff.write(_get_struct_2fB2f().pack(_x.x, _x.y, _x.regionType, _x.width, _x.height))
        _v31 = _v29.zoomParam
        _x = _v31.focalLength
        buff.write(_get_struct_H().pack(_x))
        _v32 = val1.waypointV2GimbalActuator
        _x = _v32
        buff.write(_get_struct_BH().pack(_x.DJIWaypointV2ActionActuatorGimbalOperationType, _x.actuatorIndex))
        _v33 = _v32.waypointV2GimbalActuatorRotationParam
        _x = _v33
        buff.write(_get_struct_3h6B().pack(_x.x, _x.y, _x.z, _x.ctrl_mode, _x.rollCmdIgnore, _x.pitchCmdIgnore, _x.yawCmdIgnore, _x.absYawModeRef, _x.duationTime))
        _v34 = val1.waypointV2AircraftControlActuator
        _x = _v34
        buff.write(_get_struct_BH().pack(_x.actuatorIndex, _x.DJIWaypointV2ActionActuatorAircraftControlOperationType))
        _v35 = _v34.waypointV2AircraftControlActuatorFlying
        _x = _v35.isStartFlying
        buff.write(_get_struct_B().pack(_x))
        _v36 = _v34.waypointV2AircraftControlActuatorRotateHeading
        _x = _v36
        buff.write(_get_struct_Bf().pack(_x.isRelative, _x.yaw))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.actions is None:
        self.actions = None
      end = 0
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.actions = []
      for i in range(0, length):
        val1 = dji_osdk_ros.msg.WaypointV2Action()
        _x = val1
        start = end
        end += 4
        (_x.actionId, _x.waypointV2ActionTriggerType, _x.waypointV2ACtionActuatorType,) = _get_struct_H2B().unpack(str[start:end])
        _v37 = val1.waypointV2AssociateTrigger
        _x = _v37
        start = end
        end += 4
        (_x.actionAssociatedType, _x.waitingTime, _x.actionIdAssociated,) = _get_struct_2BH().unpack(str[start:end])
        _v38 = val1.waypointV2IntervalTrigger
        _x = _v38
        start = end
        end += 5
        (_x.startIndex, _x.interval, _x.actionIntervalType,) = _get_struct_2HB().unpack(str[start:end])
        _v39 = val1.waypointV2TrajectoryTrigger
        _x = _v39
        start = end
        end += 4
        (_x.startIndex, _x.endIndex,) = _get_struct_2H().unpack(str[start:end])
        _v40 = val1.waypointV2SampleReachPointTrigger
        _x = _v40
        start = end
        end += 4
        (_x.waypointIndex, _x.terminateNum,) = _get_struct_2H().unpack(str[start:end])
        _v41 = val1.waypointV2CameraActuator
        _x = _v41
        start = end
        end += 4
        (_x.actuatorIndex, _x.DJIWaypointV2ActionActuatorCameraOperationType,) = _get_struct_2H().unpack(str[start:end])
        _v42 = _v41.focusParam
        _x = _v42
        start = end
        end += 17
        (_x.x, _x.y, _x.regionType, _x.width, _x.height,) = _get_struct_2fB2f().unpack(str[start:end])
        _v43 = _v41.zoomParam
        start = end
        end += 2
        (_v43.focalLength,) = _get_struct_H().unpack(str[start:end])
        _v44 = val1.waypointV2GimbalActuator
        _x = _v44
        start = end
        end += 3
        (_x.DJIWaypointV2ActionActuatorGimbalOperationType, _x.actuatorIndex,) = _get_struct_BH().unpack(str[start:end])
        _v45 = _v44.waypointV2GimbalActuatorRotationParam
        _x = _v45
        start = end
        end += 12
        (_x.x, _x.y, _x.z, _x.ctrl_mode, _x.rollCmdIgnore, _x.pitchCmdIgnore, _x.yawCmdIgnore, _x.absYawModeRef, _x.duationTime,) = _get_struct_3h6B().unpack(str[start:end])
        _v46 = val1.waypointV2AircraftControlActuator
        _x = _v46
        start = end
        end += 3
        (_x.actuatorIndex, _x.DJIWaypointV2ActionActuatorAircraftControlOperationType,) = _get_struct_BH().unpack(str[start:end])
        _v47 = _v46.waypointV2AircraftControlActuatorFlying
        start = end
        end += 1
        (_v47.isStartFlying,) = _get_struct_B().unpack(str[start:end])
        _v48 = _v46.waypointV2AircraftControlActuatorRotateHeading
        _x = _v48
        start = end
        end += 5
        (_x.isRelative, _x.yaw,) = _get_struct_Bf().unpack(str[start:end])
        self.actions.append(val1)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_2BH = None
def _get_struct_2BH():
    global _struct_2BH
    if _struct_2BH is None:
        _struct_2BH = struct.Struct("<2BH")
    return _struct_2BH
_struct_2H = None
def _get_struct_2H():
    global _struct_2H
    if _struct_2H is None:
        _struct_2H = struct.Struct("<2H")
    return _struct_2H
_struct_2HB = None
def _get_struct_2HB():
    global _struct_2HB
    if _struct_2HB is None:
        _struct_2HB = struct.Struct("<2HB")
    return _struct_2HB
_struct_2fB2f = None
def _get_struct_2fB2f():
    global _struct_2fB2f
    if _struct_2fB2f is None:
        _struct_2fB2f = struct.Struct("<2fB2f")
    return _struct_2fB2f
_struct_3h6B = None
def _get_struct_3h6B():
    global _struct_3h6B
    if _struct_3h6B is None:
        _struct_3h6B = struct.Struct("<3h6B")
    return _struct_3h6B
_struct_B = None
def _get_struct_B():
    global _struct_B
    if _struct_B is None:
        _struct_B = struct.Struct("<B")
    return _struct_B
_struct_BH = None
def _get_struct_BH():
    global _struct_BH
    if _struct_BH is None:
        _struct_BH = struct.Struct("<BH")
    return _struct_BH
_struct_Bf = None
def _get_struct_Bf():
    global _struct_Bf
    if _struct_Bf is None:
        _struct_Bf = struct.Struct("<Bf")
    return _struct_Bf
_struct_H = None
def _get_struct_H():
    global _struct_H
    if _struct_H is None:
        _struct_H = struct.Struct("<H")
    return _struct_H
_struct_H2B = None
def _get_struct_H2B():
    global _struct_H2B
    if _struct_H2B is None:
        _struct_H2B = struct.Struct("<H2B")
    return _struct_H2B
# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from dji_osdk_ros/GenerateWaypointV2ActionResponse.msg. Do not edit."""
import codecs
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct


class GenerateWaypointV2ActionResponse(genpy.Message):
  _md5sum = "eb13ac1f1354ccecb7941ee8fa2192e8"
  _type = "dji_osdk_ros/GenerateWaypointV2ActionResponse"
  _has_header = False  # flag to mark the presence of a Header object
  _full_text = """#response
bool result
"""
  __slots__ = ['result']
  _slot_types = ['bool']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       result

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(GenerateWaypointV2ActionResponse, self).__init__(*args, **kwds)
      # message fields cannot be None, assign default values for those that are
      if self.result is None:
        self.result = False
    else:
      self.result = False

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self.result
      buff.write(_get_struct_B().pack(_x))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      end = 0
      start = end
      end += 1
      (self.result,) = _get_struct_B().unpack(str[start:end])
      self.result = bool(self.result)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self.result
      buff.write(_get_struct_B().pack(_x))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      end = 0
      start = end
      end += 1
      (self.result,) = _get_struct_B().unpack(str[start:end])
      self.result = bool(self.result)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_B = None
def _get_struct_B():
    global _struct_B
    if _struct_B is None:
        _struct_B = struct.Struct("<B")
    return _struct_B
class GenerateWaypointV2Action(object):
  _type          = 'dji_osdk_ros/GenerateWaypointV2Action'
  _md5sum = 'ee1e22d538fec9eb15d560136ab324dc'
  _request_class  = GenerateWaypointV2ActionRequest
  _response_class = GenerateWaypointV2ActionResponse
